# Prime Number Selection

There are two methods for prime number screening , Ehrlich sieve method and Euler sieve method （ Linear sieve ）  
The Ehrlich sieve method is easy to understand but takes a long time to run  
Eulerian sieve method is an upgraded version of Ehrlich sieve method

---

**Ethmoidal method**  
Ehrlich sieve method is to exclude multiples of prime numbers , Thus leaving behind prime numbers  
Because prime numbers are only 1 Divide by itself , So it will not be excluded  
For example, from 2 Start ,4、6、8、… Excluded  
Again from 3 Start ,6、9、12、… Excluded  
because 4 Excluded , Again from 5 Start  
And so on until n

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=100000010;
bool a[N];
int main()
{
    
	int i,j,n,m,num;
	scanf("%d",&n);
	a[0]=a[1]=1;
	num=0;
	for(i=0;i<=n;i++)
	{
    
		if(a[i]) continue;// Composite numbers skip directly  
		num++;
		for(j=i;j<=n;j+=i)
		{
    
			a[j]=1;// take i All multiples of are excluded  
		}
	}
	printf("%d\n",num);
}

```

But there are too many repeated judgments , for example 12, To be 2、4、6 Judge , So it takes a long time

---

**Euler sieve method （ Linear sieve ）**  
The idea is similar to that of the Ehrlich sieve method  
But storing prime numbers in arrays , When filtering, use the prime number in the array to judge , Reduce the number of judgments

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=100000010;
int st[N],primes[N],n,cnt;
void get_primes(int n)// Linear sieve prime number 
{
    
    for (int i=2;i<=n;i++)
    {
    
        if(!st[i]) primes[++cnt]=i;// Store numbers into prime arrays  
        for(int j=1;primes[j]*i<=n;j++)
        {
    
            st[primes[j]*i]=true;// Multiples of prime numbers  
            if(i%primes[j]==0) break;// If this number is a multiple of a prime number, end the loop  
        }
    }
}
int main()
{
    
	cnt=0;
	scanf("%d",&n);
	get_primes(n);
	printf("%d\n",cnt);
}
```

